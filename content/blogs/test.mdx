---
title: "How I Built a Scalable Multi-Environment Infrastructure on GCP Using Terraform"
summary: "A complete guide to building scalable, isolated, multi-environment infrastructure on Google Cloud using Terraform and Cloud Build — by RizeForge."
tags: ["terraform", "gcp", "devops", "cloud", "infrastructure"]
banner: "/images/mastering-multi-environment-infrastructure-gcp-terraform.png"
publishedAt: "2025-06-29"
---

Hi, I’m **RizeForge**, a software engineer passionate about **DevOps automation and cloud infrastructure design**.

This project reflects my experience architecting **multi-environment Terraform infrastructure on Google Cloud**, ensuring every deployment — from development to production — remains consistent, secure, and scalable.

This post documents how I approached the problem, designed a modular setup, automated CI/CD with Cloud Build, and applied best practices for long-term maintainability.

---

## 🧠 Overview

Managing multiple environments in cloud infrastructure is one of the hardest DevOps challenges.  
This case study explains how I built a **production-ready, multi-environment Terraform setup on GCP** — clean, modular, secure, and CI/CD-driven.  

The result: isolated environments, reusable modules, automated pipelines, and bulletproof state management — a foundation that has scaled across multiple internal projects.

---

## 🧩 Tech Stack

```bash filename="stack.txt"
Cloud Provider: Google Cloud Platform (GCP)
IaC Tool: Terraform (v1.5+)
CI/CD: Google Cloud Build
Scripting: Bash
State Management: GCS Buckets (per environment)
Monitoring: Cloud Monitoring + Alerting
````

---

## ⚙️ Architecture & Project Structure

To ensure scalability, I used a **modular directory structure** that separates reusable infrastructure logic from environment-specific configuration:

```text
my-gcp-infrastructure/
├── modules/
│   ├── compute/
│   ├── networking/
│   ├── storage/
│   └── monitoring/
├── environments/
│   ├── dev/
│   ├── staging/
│   └── prod/
├── scripts/
│   ├── deploy.sh
│   ├── destroy.sh
│   └── validate.sh
└── cloudbuild/
    ├── cloudbuild-dev.yaml
    ├── cloudbuild-staging.yaml
    └── cloudbuild-prod.yaml
```

**Why this matters:**

* ✅ Clear separation of reusable modules and configurations.
* 🔒 Environment isolation through separate backend states.
* ⚙️ CI/CD flexibility with environment-specific pipelines.

---

## 🧱 Environment Configuration

Each environment (Dev, Staging, Prod) includes dedicated variable, backend, and tfvars files.

```hcl filename="environments/dev/variables.tf"
variable "project_id" { type = string }
variable "region"     { type = string; default = "us-central1" }
variable "zone"       { type = string; default = "us-central1-a" }
variable "environment" {
  type = string
  validation {
    condition = contains(["dev","staging","prod"], var.environment)
    error_message = "Must be dev, staging, or prod."
  }
}
variable "app_name" { type = string }
variable "instance_type" { type = string; default = "e2-micro" }
variable "min_replicas"  { type = number; default = 1 }
variable "max_replicas"  { type = number; default = 3 }
```

```hcl filename="environments/dev/backend.tf"
terraform {
  backend "gcs" {
    bucket = "tf-state-rizeforge-dev"
    prefix = "terraform/state"
  }
}
provider "google" {
  project = var.project_id
  region  = var.region
  zone    = var.zone
}
```

---

## 🧠 Automating State Management

To prevent accidental cross-environment overwrites, I created a shell script that provisions **versioned GCS buckets** per environment:

```bash filename="scripts/create-state-buckets.sh"
#!/bin/bash
PROJECT_ID="rizeforge-dev"
for env in dev staging prod; do
  BUCKET="tf-state-rizeforge-$env"
  gsutil mb -p "$PROJECT_ID" -l us-central1 "gs://$BUCKET"
  gsutil versioning set on "gs://$BUCKET"
  gsutil uniformbucketlevelaccess set on "gs://$BUCKET"
done
```

This ensures **state isolation**, **auditable versioning**, and **automatic retention**.

---

## 🧩 Terraform Modules

### 🛰️ Networking Module

```hcl
resource "google_compute_network" "main" {
  name                    = "${var.app_name}-${var.environment}-vpc"
  auto_create_subnetworks = false
}
resource "google_compute_subnetwork" "app" {
  name          = "${var.app_name}-${var.environment}-subnet"
  ip_cidr_range = "10.0.0.0/24"
  region        = var.region
  network       = google_compute_network.main.id
}
```

### 💻 Compute Module

```hcl
resource "google_compute_instance_template" "app" {
  name_prefix  = "${var.app_name}-${var.environment}-template-"
  machine_type = var.instance_type
  disk {
    boot         = true
    source_image = "debian-cloud/debian-11"
  }
}
```

### 📊 Monitoring Module

```hcl
resource "google_monitoring_alert_policy" "high_cpu" {
  display_name = "${var.app_name}-${var.environment} High CPU"
  combiner     = "OR"
  conditions {
    condition_threshold {
      filter          = "metric.type=\"compute.googleapis.com/instance/cpu/utilization\""
      comparison      = "COMPARISON_GT"
      threshold_value = 0.8
      duration        = "300s"
    }
  }
}
```

---

## 🔐 Security Best Practices

* **Dedicated service accounts** per environment (Terraform, application, monitoring).
* **Least privilege IAM** to reduce the blast radius.
* **Workload Identity Federation** to eliminate static credentials.
* **Versioned GCS backends** for traceability and rollback.

---

## ⚙️ CI/CD with Cloud Build

```yaml filename="cloudbuild/cloudbuild-dev.yaml"
steps:
  - name: 'gcr.io/cloud-builders/terraform'
    args: ['init']
    dir: 'environments/dev'
  - name: 'gcr.io/cloud-builders/terraform'
    args: ['plan', '-out=tfplan']
    dir: 'environments/dev'
  - name: 'gcr.io/cloud-builders/terraform'
    args: ['apply', '-auto-approve', 'tfplan']
    dir: 'environments/dev'
substitutions:
  _PROJECT_ID: 'rizeforge-dev'
timeout: 1200s
```

Each environment runs a dedicated pipeline, ensuring reproducible deployments and easier rollback.

---

## 📊 Results

* ⚡ **100% automated multi-environment deployments** (dev → staging → prod).
* 🔒 **Isolated state management** prevents conflicts and drift.
* 📈 **Reusable Terraform modules** speed up onboarding for new infrastructure.
* 🌐 **Integrated monitoring** ensures proactive alerting and observability.

---

## 🚀 Lessons Learned

* Enforcing environment isolation early simplifies future scaling.
* Modular design allows infrastructure reuse across multiple projects.
* CI/CD validation (plan → approval → apply) reduces human error.
* GCS state versioning is invaluable for debugging and rollbacks.
